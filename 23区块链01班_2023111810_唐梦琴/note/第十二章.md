# 唐梦琴 的学习笔记

## 基本信息
- **学号**: 2023111810
- **班级**: 23区块链01班
- **姓名**: 唐梦琴

## 学习记录

### 课程笔记
-
并发编程
并发：多个任务在同一时间段内执行
并行：多个任务在同一时刻执行

在操作系统下，线程是独立运行和独立调度的基本单位
一个进程可以包含多个线程，一个线程可以拥有多个协程，线程是容器中的工作单位

使用go实现协程

channel：引用类型
语法
var channel 变量 chan channel类型
ch1 := make(chan int)   //创建一个int类型的channel
实现接口下所有方法就代表实现了接口
旧版：interface{}可以代表任意类型
新版：any代替任意类型
ch2 := make(chan interface{})
等价于
ch2 := make(chan any)

使用channel发送数据
语法：channel 变量 <- 值
data := <-channel 变量
data,ok := <- channel变量
ok：channel是否被关闭
可以从关闭的channel中读取数据
close(channel变量)：关闭channel
单向Channel：只能发送或接收数据，不能同时发送和接收


Time包
time.Now()当前时间

select分支语句
select {
//抢占式：多个case同时满足时，随机选择一个执行
case data := <-channel变量:
    // 处理从channel变量接收的数据
case data := <-channel变量2:
    // 处理从channel变量2接收的数据
default:    //不需要等待
    // 如果channel为空，执行默认操作
}

sync包
WaitGroup同步等待组：等待一组线程结束
Wait()：等待所有等待的goroutine结束,才会进行下一步
done()：计数器-1，结束后使用

互斥锁：Mutex
mutex.Lock()：加锁
mutex.Unlock()：解锁
e.g.多个售票窗口同时售票

读写锁：RWMutex
写操作是互斥的，读和写是互斥的，读和读不互斥
Lock()：加锁
Unlock()：解锁
RLock()：加读锁
RUnlock()：解锁
Signal()：唤醒一个等待的goroutine
Wait() ：等待所有等待的goroutine结束

### 作业记录
- 

### 项目经验
- 

### 学习心得
- 

---
*创建时间: 2025-09-25 08:57:45*